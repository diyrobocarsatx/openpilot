******************************************************
******** START ***************************************
******************************************************

2018 4 19 12 47  main() [selfdrive/manager.py] 

> main() call params = Params() [selfdrive/manager.py]
  > Params(object).__init__() START
     openpilot/common/params.py
> main() call params.manager_start() [selfdrive/manager.py]
  > manager_start() openpilot/common/params.py
    > call self._clear_keys_with_type()
  > Params.put() openpilot/common/params.py
    set Passive
> main() try: call manager_update() [selfdrive/manager.py]
> main() try: call manager_init() [selfdrive/manager.py]
  > Params(object).__init__() START
     openpilot/common/params.py
  > Params.put() openpilot/common/params.py
    set Version
dinfo 1920x1080
  > Params.put() openpilot/common/params.py
    set GitCommit
egl version 1.4
egl w 1920 h 1080
gl version OpenGL ES 3.2 V@145.0 (GIT@I0ac3940325)
  > Params.put() openpilot/common/params.py
    set GitBranch
  > Params.put() openpilot/common/params.py
    set GitRemote
fatal: bad revision 'origin/release2'
dirty is 1
> main() try: call manager_prepare() [selfdrive/manager.py]
  > manager_prepare() START [selfdrive/manager.py]

    # [manager_prepare()] build cereal first (openpilot comment)
make: Nothing to be done for 'all'.
  > [manager_prepare()] build all processes (openpilot comment)
   > [manager_prepare()] call prepare_managed_process(p) pandad
       > prepare_managed_process(p) START [manager.py]
preimporting selfdrive.pandad

       > prepare_managed_process(p) END [manager.py]
   > [manager_prepare()] call prepare_managed_process(p) visiond
       > prepare_managed_process(p) START [manager.py]
        building ('selfdrive/visiond', ['./visiond'])

visiond: this is a release
       > prepare_managed_process(p) END [manager.py]
   > [manager_prepare()] call prepare_managed_process(p) sensord
       > prepare_managed_process(p) START [manager.py]
        building ('selfdrive/sensord', ['./sensord'])

sensord: this is a release
       > prepare_managed_process(p) END [manager.py]
   > [manager_prepare()] call prepare_managed_process(p) boardd
       > prepare_managed_process(p) START [manager.py]
        building ('selfdrive/boardd', ['./boardd'])

make: Nothing to be done for 'all'.
       > prepare_managed_process(p) END [manager.py]
   > [manager_prepare()] call prepare_managed_process(p) ui
       > prepare_managed_process(p) START [manager.py]
        building ('selfdrive/ui', ['./ui'])

make: Nothing to be done for 'all'.
       > prepare_managed_process(p) END [manager.py]
   > [manager_prepare()] call prepare_managed_process(p) controlsd
       > prepare_managed_process(p) START [manager.py]
preimporting selfdrive.controls.controlsd

make: Nothing to be done for 'all'.
make: Nothing to be done for 'all'.
> CarInterface().__init__() END *****
make: Nothing to be done for 'all'.
> [controlsd.py] State = log.Live100Data.ControlState =  <capnp.lib.capnp._EnumModule object at 0x7f857985d0>
       > prepare_managed_process(p) END [manager.py]
  >
 manager_prepare() END [selfdrive/manager.py]

> main() try: call manager_thread() [selfdrive/manager.py]

  > ***** manager_thread() START ***** [selfdrive/manager.py]

    > [manager_thread()] for persistent processes call loop start_managed_processes()
       > [start_managed_process(name)] name =  logmessaged
       > [start_managed_process()]  logmessaged is already running or is not a managed process
       > [start_managed_process(name)] name =  logcatd
       > [start_managed_process()]  logcatd is already running or is not a managed process
       > [start_managed_process(name)] name =  tombstoned
       > [start_managed_process()]  tombstoned is already running or is not a managed process
       > [start_managed_process(name)] name =  uploader
       > [start_managed_process()]  uploader is already running or is not a managed process
       > [start_managed_process(name)] name =  ui
starting process ui

       > [start_managed_process(name)] name =  gpsd
       > [start_managed_process()]  gpsd is already running or is not a managed process
       > [start_managed_process(name)] name =  updated
       > [start_managed_process()]  updated is already running or is not a managed process
dinfo 1920x1080
egl version 1.4
egl w 1920 h 1080
gl version OpenGL ES 3.2 V@145.0 (GIT@I0ac3940325)
dinfo 1920x1080
egl version 1.4
egl w 1920 h 1080
gl version OpenGL ES 3.2 V@145.0 (GIT@I0ac3940325)
       > [start_managed_process(name)] name =  pandad
starting python selfdrive.pandad

    > [manager_thread()] call params = Params() [selfdrive/manager.py]
  > Params(object).__init__() START
     openpilot/common/params.py
      > [manager_thread()] params =  <common.params.Params object at 0x7f840eaad0>
    > [manager_thread()] call passive = params.get('Passive') == 1 [selfdrive/manager.py]
      > [manager_thread()] passive =  False
      > [manager_thread()] ignition_seen =  False

    > [manager_thread()] ***** while 1 loop START
      > [manager_thread() while 1 loop] call td = messaging.recv_sock(health_sock, wait=True)
  > selfdrive/messaging.py recv_sock() sock =  17 return dat
opening device none 0xddcc
connected
v1.0.7-unknown-DEBUG should be v1.0.7
boardd.cc: starting boardd
boardd.cc: waiting for params to set safety model
boardd.cc: connected to board
boardd.cc: got 352 bytes CarParams
boardd.cc: setting safety model: 2 with param 73
      > [manager_thread() while 1 loop] call location = messaging.recv_sock(location_sock)
  > selfdrive/messaging.py recv_sock() sock =  18 return dat
      > [manager_thread()] while 1 loop call thermal_sock.send()
      > [manager_thread()] while 1 loop msg = ... 
       > [start_managed_process(name)] name =  uploader
       > [start_managed_process()]  uploader is already running or is not a managed process
  > [manager_thread() while 1 loop] should_start =  True
  > [manager_thread() while 1 loop, if should_start] call params.car_start()
     > car_start() openpilot/common/params.py
       > calls self._clear_keys_with_type()
  > [manager_thread() while 1 loop] call start_managed_process(p)  controlsd
       > [start_managed_process(name)] name =  controlsd
starting python selfdrive.controls.controlsd

  > [manager_thread() while 1 loop] call start_managed_process(p)  loggerd
       > [start_managed_process(name)] name =  loggerd
       > [start_managed_process()]  loggerd is already running or is not a managed process
  > [manager_thread() while 1 loop] call start_managed_process(p)  sensord
       > [start_managed_process(name)] name =  sensord
starting process sensord

  > [manager_thread() while 1 loop] call start_managed_process(p)  radard
       > [start_managed_process(name)] name =  radard
       > [start_managed_process()]  radard is already running or is not a managed process
  > [manager_thread() while 1 loop] call start_managed_process(p)  visiond
       > [start_managed_process(name)] name =  visiond
starting process visiond



2018 4 19 12 47 selfdrive/controls/controlsd.py main()
***** > controls_thread() START ***** selfdrive/controls/controlsd.py

  > [manager_thread() while 1 loop] call start_managed_process(p)  proclogd
       > [start_managed_process(name)] name =  proclogd
       > [start_managed_process()]  proclogd is already running or is not a managed process

     > [manager_thread()] ***** while 1 loop END *****


    > [manager_thread()] ***** while 1 loop START
      > [manager_thread() while 1 loop] call td = messaging.recv_sock(health_sock, wait=True)
  > selfdrive/messaging.py recv_sock() sock =  17 return dat
vendor: 'QUALCOMM'
platform version: 'OpenCL 2.0 QUALCOMM build: commit #6ff34ae changeid #I0ac3940325 Date: 09/23/16 Fri Local Branch:  Remote Branch: refs/tags/AU_LINUX_ANDROID_LA.HB.1.3.2.06.00.01.214.261'
profile: 'FULL_PROFILE'
extensions: ' '
name: 'QUALCOMM Adreno(TM)'
device version: 'OpenCL 2.0 Adreno(TM) 530'
type = 0x0004 = CL_DEVICE_TYPE_GPU

pid 28972's current scheduling policy: SCHED_OTHER
pid 28972's current scheduling priority: 0
pid 28972's new scheduling policy: SCHED_FIFO
pid 28972's new scheduling priority: 3
> [controls_thread()] call params = Params()
  > Params(object).__init__() START
     openpilot/common/params.py
> [controls_thread()] params.get("Passive") =  0
> [controls_thread()] passive = params.get("Passive") != 0 False 

> [controls_thread()] sendcan =  <zmq.sugar.socket.Socket object at 0x7f840ec668>
> [controls_thread()] create logcan subscription socket on can port
> [controls_thread()] type(logcan) =  <class 'zmq.sugar.socket.Socket'>
> [controls_thread()] CC = car.CarControl.new_message()
> [controls_thread()] call get_car(logcan, sendcan) returns CI, CP -- CI is Car Interface and CP is Car Parameters

  > [__init__.py] get_car(logcan, sendcan) START **** return interface_cls(params, sendcan), params selfdrive/car

  > [get_car()] call candidate, fingerprint = fingerprint(logcan, timeout)
> [get_car()] timeout =  None
> [get_car()] passive =  None
  > [__init__.py] fingerprint(logcan, timeout) return candidate_cars[0], finger selfdrive/car/__init__.py
  > [fingerprint()] call candidate_cars = all_known_cars()

> all_known_cars() openpilot/common/fingerprints.py
  > # Returns a list of all known car strings (openpilot comment) all_known_cars()
  > [fingerprints.py all_known_cars()] _Fingerprints.keys() =  ['TOYOTA RAV4 2017 HYBRID', 'ACURA RDX 2018 ACURAWATCH PLUS', 'TOYOTA COROLLA 2017', 'TOYOTA PRIUS 2017', 'LEXUS RX HYBRID 2017', 'HONDA PILOT 2017 TOURING', 'ACURA ILX 2016 ACURAWATCH PLUS', 'HONDA ODYSSEY 2018 EX-L', 'HONDA CIVIC 2016 TOURING', 'HONDA CR-V 2016 TOURING'] 

 [fingerprint()]    waiting for fingerprint...

    > [fingerprint()] st =  None
    > [fingerprint()]  call messaging.drain_sock(logcan, ...)
      > selfdrive/messaging.py drain_sock(sock)
      > selfdrive/messaging.py drain_sock(sock) wait_for_one =  False
      > selfdrive/messaging.py drain_sock() call dat = sock.recv(zmq.NOBLOCK)
      > selfdrive/messaging.py drain_sock() returns ret =  []
     > [fingerprint()] ts =  259117.439185
     > [fingerprint()] len(candidate_cars) =  10
     > [fingerprint()] st =  259117.439166
     > [fingerprint()] timeout =  None
     > [fingerprint()] finger_st =  259117.435231
     > [fingerprint()] (timeout and ts-finger_st > timeout) =  None
    > [fingerprint()] while 1 loop END ***

 > ***   [fingerprint()] fingerprinted =  TOYOTA RAV4 2017 HYBRID
 > ***   [fingerprint()] finger =  {} 

 > fingerprint() END *** car/__init__.py

  > [get_car()] candidate =  TOYOTA RAV4 2017 HYBRID
  > [get_car()] interface_cls =  <class 'selfdrive.car.toyota.interface.CarInterface'>
  > [get_car()] fingerprints =  {}
  > [get_car()] call params = interface_cls.get_params(candidate, fingerprints)

> [interface.py] CarInterface.get_params(candidate, fingerprint) START *****
  > [get_params()] ret = car.CarParams.new_message()
  > [get_params()]  call ret.enableCamera = not check_ecu_msgs(fingerprint, candidate, ECU.CAM)
> selfdrive/car/toyota/values.py check_ecu_msgs(fingerprint, candidate, ecu)
  > # return True if fingerprint contains messages normally sent by a given ecu (openpilot comment)
  > [get_params()]  call ret.enableCamera = not check_ecu_msgs(fingerprint, candidate, ECU.DSU)
> selfdrive/car/toyota/values.py check_ecu_msgs(fingerprint, candidate, ecu)
  > # return True if fingerprint contains messages normally sent by a given ecu (openpilot comment)
ECU Camera Simulated:  True
ECU DSU Simulated:  True
ECU APGS Simulated:  False
> get_params() END ***** selfdrive/car/toyota/interface.py

> [get_car()]  call interface_class(params, sendcan)
> CarInterface(object).__init__(CP) START *****  [selfdrive/car/toyota/interface.py]
> [CarInterface().__init__()] call VehicleModel(CP)
> VehicleModel(object).__init__(CP) START selfdrive/controls/lib/vehicle_model.py
> [CarInterface().__init__()] *** init the major players *** (openpilot comment)
  > [CarInterface().__init__()] call self.CS = CarState(CP)
> CarState(object).__init__(CP) START selfdrive/car/toyota/carstate.py
   > [CarState(object).__init__()] type(self.CP) =  <type 'capnp.lib.capnp._DynamicStructBuilder'>
   > [CarState(object).__init__()] self.CP =  ( carName = "toyota",
  carFingerprint = "TOYOTA RAV4 2017 HYBRID",
  enableSteer = true,
  enableGas = true,
  enableBrake = true,
  enableCruise = true,
  mass = 1791.3289,
  wheelbase = 2.65,
  centerToFront = 1.166,
  steerRatio = 14.5,
  steerRatioRear = 0,
  rotationalInertia = 2951.5085,
  tireStiffnessFront = 97686.477,
  tireStiffnessRear = 121331.89,
  steerKp = 0.6,
  steerKi = 0.05,
  minEnableSpeed = -1,
  safetyModel = 2,
  steerMaxBP = [4.4444447, 12.5],
  steerMaxV = [1, 1],
  gasMaxBP = [0],
  gasMaxV = [0.5],
  brakeMaxBP = [5, 20],
  brakeMaxV = [1, 0.8],
  steerKf = 6e-05,
  enableCamera = true,
  enableDsu = true,
  enableApgs = false,
  steerLimitAlert = false,
  vEgoStopping = 0,
  directAccelControl = false,
  longPidDeadzoneBP = [0, 9],
  longPidDeadzoneV = [0, 0.15],
  stoppingControl = false,
  startAccel = 0,
  longitudinalKpBP = [0, 5, 35],
  longitudinalKpV = [3.6, 2.4, 1.5],
  longitudinalKiBP = [0, 35],
  longitudinalKiV = [0.54, 0.36],
  steerRateCost = 1,
  safetyParam = 73 )
   # initialize can parser (openpilot comment) [CarState(object).__init__()]
   > [CarState(object).__init__()] self.car_fingerprint =  TOYOTA RAV4 2017 HYBRID
  > [CarInterface().__init__()]  call self.cp = get_can_parser(CP)
    > get_can_parser(CP) return CANParser object selfdrive/car/toyota/carstate.py
      > # this function generates lists for signal, messages and initial values (openpilot comment) carstate.py get_can_parser()
    > call CANParser(dbc_f, signals, checks) selfdrive/car/toyota/carstate.py get_can_parser()
> CANParser(object).__init__(dbc_name, signals, checks) START ***** [selfdrive/can/parser.py]
  > [CANParser().__init__()] dbc_name =  toyota_rav4_hybrid_2017_pt_generated
  > [CANParser().__init__()] signals = ...
  > [CANParser().__init__()] checks = ...
  > [CANParser().__init__()] call libdbc.dbc_lookup(dbc_name)
  > [CANParser().__init__()] dbc =  <cdata 'DBC *' 0x7f83e6eca8>
   > [CANParser().__init__()] num_msgs =  26
   > [CANParser().__init__()] message Id =  36    message name =  KINEMATICS
   > [CANParser().__init__()] msg =  <cdata 'Msg &' 0x7f83e6ecc0>
   > [CANParser().__init__()] message Id =  37    message name =  STEER_ANGLE_SENSOR
   > [CANParser().__init__()] msg =  <cdata 'Msg &' 0x7f83e6ece0>
   > [CANParser().__init__()] message Id =  166    message name =  BRAKE
   > [CANParser().__init__()] msg =  <cdata 'Msg &' 0x7f83e6ed00>
   > [CANParser().__init__()] message Id =  170    message name =  WHEEL_SPEEDS
   > [CANParser().__init__()] msg =  <cdata 'Msg &' 0x7f83e6ed20>
   > [CANParser().__init__()] message Id =  180    message name =  SPEED
   > [CANParser().__init__()] msg =  <cdata 'Msg &' 0x7f83e6ed40>
   > [CANParser().__init__()] message Id =  466    message name =  PCM_CRUISE
   > [CANParser().__init__()] msg =  <cdata 'Msg &' 0x7f83e6ed60>
   > [CANParser().__init__()] message Id =  467    message name =  PCM_CRUISE_2
   > [CANParser().__init__()] msg =  <cdata 'Msg &' 0x7f83e6ed80>
   > [CANParser().__init__()] message Id =  550    message name =  BRAKE_MODULE
   > [CANParser().__init__()] msg =  <cdata 'Msg &' 0x7f83e6eda0>
   > [CANParser().__init__()] message Id =  552    message name =  ACCELEROMETER
   > [CANParser().__init__()] msg =  <cdata 'Msg &' 0x7f83e6edc0>
   > [CANParser().__init__()] message Id =  560    message name =  BRAKE_MODULE2
   > [CANParser().__init__()] msg =  <cdata 'Msg &' 0x7f83e6ede0>
   > [CANParser().__init__()] message Id =  581    message name =  GAS_PEDAL
   > [CANParser().__init__()] msg =  <cdata 'Msg &' 0x7f83e6ee00>
   > [CANParser().__init__()] message Id =  608    message name =  STEER_TORQUE_SENSOR
   > [CANParser().__init__()] msg =  <cdata 'Msg &' 0x7f83e6ee20>
   > [CANParser().__init__()] message Id =  610    message name =  EPS_STATUS
   > [CANParser().__init__()] msg =  <cdata 'Msg &' 0x7f83e6ee40>
   > [CANParser().__init__()] message Id =  614    message name =  STEERING_IPAS
   > [CANParser().__init__()] msg =  <cdata 'Msg &' 0x7f83e6ee60>
   > [CANParser().__init__()] message Id =  740    message name =  STEERING_LKA
   > [CANParser().__init__()] msg =  <cdata 'Msg &' 0x7f83e6ee80>
   > [CANParser().__init__()] message Id =  742    message name =  LEAD_INFO
   > [CANParser().__init__()] msg =  <cdata 'Msg &' 0x7f83e6eea0>
   > [CANParser().__init__()] message Id =  835    message name =  ACC_CONTROL
   > [CANParser().__init__()] msg =  <cdata 'Msg &' 0x7f83e6eec0>
   > [CANParser().__init__()] message Id =  921    message name =  PCM_CRUISE_SM
   > [CANParser().__init__()] msg =  <cdata 'Msg &' 0x7f83e6eee0>
   > [CANParser().__init__()] message Id =  951    message name =  ESP_CONTROL
   > [CANParser().__init__()] msg =  <cdata 'Msg &' 0x7f83e6ef00>
   > [CANParser().__init__()] message Id =  956    message name =  GEAR_PACKET
   > [CANParser().__init__()] msg =  <cdata 'Msg &' 0x7f83e6ef20>
   > [CANParser().__init__()] message Id =  1041    message name =  ACC_HUD
   > [CANParser().__init__()] msg =  <cdata 'Msg &' 0x7f83e6ef40>
   > [CANParser().__init__()] message Id =  1042    message name =  LKAS_HUD
   > [CANParser().__init__()] msg =  <cdata 'Msg &' 0x7f83e6ef60>
   > [CANParser().__init__()] message Id =  1553    message name =  UI_SEETING
   > [CANParser().__init__()] msg =  <cdata 'Msg &' 0x7f83e6ef80>
   > [CANParser().__init__()] message Id =  1556    message name =  STEERING_LEVERS
   > [CANParser().__init__()] msg =  <cdata 'Msg &' 0x7f83e6efa0>
   > [CANParser().__init__()] message Id =  1568    message name =  SEATS_DOORS
   > [CANParser().__init__()] msg =  <cdata 'Msg &' 0x7f83e6efc0>
   > [CANParser().__init__()] message Id =  1570    message name =  LIGHT_STALK
   > [CANParser().__init__()] msg =  <cdata 'Msg &' 0x7f83e6efe0>
  > [CANParser().__init__()] name to address dictionary ...
  > [CANParser().__init__()] address to name dictionary ...
  > [CANParser().__init__()]  # Convert message names into addresses (openpilot comment)
  > [CANParser().__init__()] # set default values by name (openpilot comment)
  > [CANParser().__init__()]  call self.can = libdbc.can_init(bus, dbc_name, ...)
  > [CANParser().__init__()] self.can =  <cdata 'void *' 0x7f83f31120>
   > [CANParser().__init__()] call self.update_vl()
> CANParser(object).update_vl(sec) START ***** return ret
> CANParser().update_vl() END ***** return ret [parser.py CANParser()]
  > [CarInterface().__init__()]  call self.CC = CarController(CP.carFingerprint)
  > [CarInterface(object).__init__()] CP.carFingerprint =  TOYOTA RAV4 2017 HYBRID
> CarController(object).__init__(car_fingerprint, enable_camera, enable_dsu, enable_apg) START selfdrive/car/toyota/carcontroller.py
> [CarController(object).__init__()] self.car_fingerprint =  TOYOTA RAV4 2017 HYBRID
> [controls_thread()] call PL = Planner(CP)
> selfdrive/controls/lib/planner.py Planner(object).__init__()
> selfdrive/controls/lib/planner.py Planner(object).__init__() call self.PP = PathPlanner()
> selfdrive/controls/lib/pathplanner.py PathPlanner(object).__init__()
model: building...
> [controls_thread()] call LoC = LongControl(CP, CI.compute_b) controls_thread()
> [controls_thread()] call VM = VehicleModel(CP)
> VehicleModel(object).__init__(CP) START selfdrive/controls/lib/vehicle_model.py
> [controls_thread()] call LaC = LatControl(VM)
> [controls_thread()] call AM = AlertManager()
{'event': 'alert_add', 'alert_type': 'startup', 'enabled': False}
> [controls_thread()] call params.put(CarParams, CP.to_bytes()) controlsd.py
  > Params.put() openpilot/common/params.py
    set CarParams
model: done

> ***** [controls_thread()] while 1 loop START *****
   counter =  1
   # [controls_thread() while 1 loop]  SAMPLE DATA and compute car events LatControl (openpilot comment)
     > [controls_thread() while 1 loop]  call data_sample(CI, CC, ...)
        > data_sample(CI, CC) return CS, events selfdrive/controls/controlsd.py
          > read can and compute car states (openpilot comment) data_sample()
          > call CS = CI.update(CC) data_sample()
> CarInterface(object).update(c) START ***** returns car.Carstate [selfdrive/car/toyota/interface.py]
  > [CarInterface().update()] call self.cp.update(self.cp)
> [parser.py] CANParser().update() START ***** return self.update_vl()
> [CANParser().update()] call libdbc.can_update(self.can, ...)
> CANParser().update() END ***** return self.update_vl() [parser.py CANParser()]
> CANParser(object).update_vl(sec) START ***** return ret
> CANParser().update_vl() END ***** return ret [parser.py CANParser()]
  > [CarInterface().update()] call self.CS.update(self.cp)
          > CarState(object).update(cp) selfdrive/car/toyota/carstate.py
            > cp =  <selfdrive.can.parser.CANParser object at 0x7f840f7790>
            > type(cp)  <class 'selfdrive.can.parser.CANParser'>
        > [CarInterface().update()] create message ret = car.CarState.new_message()
        > events = list(CS.events) data_sample()
           > [data_sample] CS =  ( vEgo = 0,
  wheelSpeeds = (fl = 0, fr = 0, rl = 0, rr = 0),
  gas = 0,
  gasPressed = false,
  brake = 0,
  brakePressed = false,
  steeringAngle = 0,
  steeringTorque = 0,
  steeringPressed = false,
  cruiseState = (
    enabled = false,
    speed = 0,
    available = false,
    speedOffset = 0,
    standstill = false ),
  buttonEvents = [],
  canMonoTimes = [],
  events = [
    ( name = doorOpen,
      enable = false,
      noEntry = true,
      warning = false,
      userDisable = false,
      softDisable = true,
      immediateDisable = false,
      preEnable = false,
      permanent = false ),
    ( name = seatbeltNotLatched,
      enable = false,
      noEntry = true,
      warning = false,
      userDisable = false,
      softDisable = true,
      immediateDisable = false,
      preEnable = false,
      permanent = false ),
    ( name = espDisabled,
      enable = false,
      noEntry = true,
      warning = false,
      userDisable = false,
      softDisable = true,
      immediateDisable = false,
      preEnable = false,
      permanent = false ),
    ( name = wrongCarMode,
      enable = false,
      noEntry = true,
      warning = false,
      userDisable = true,
      softDisable = false,
      immediateDisable = false,
      preEnable = false,
      permanent = false ),
    ( name = pcmDisable,
      enable = false,
      noEntry = false,
      warning = false,
      userDisable = true,
      softDisable = false,
      immediateDisable = false,
      preEnable = false,
      permanent = false ) ],
  gearShifter = drive,
  steeringRate = 0,
  aEgo = 0,
  vEgoRaw = 0,
  standstill = true,
  brakeLights = false,
  leftBlinker = false,
  rightBlinker = false,
  yawRate = 0,
  genericToggle = false,
  doorOpen = true,
  seatbeltUnlatched = true ) selfdrive/controls/controlsd.py data_sample()

> ***** data_sample() END *****

   # [controls_thread() while 1 loop]  DEFINE PLAN (openpilot comment)
     > [controls_thread() while 1 loop]  call calc_plan(CS, events, PL, LoC, ...)
       > calc_plan(CS, events) selfdrive/controls/controlsd.py
         > call plan_packet = PL.update(CS, LoC, ...) controlsd.py calc_plan()
       > selfdrive/controls/lib/planner.py choose_solution() returns plan_send
           > ***** calc_plan() END *****

   # [controls_thread() while 1 loop]  UPDATE CONTROL STATE (openpilot comment)
    > [controls_thread() while 1 loop]  call state_transition(CS, CP, state, events, ...)
     > state_transition(CS, CP, state, events, ...) selfdrive/controls/controlsd.py
       > [state_transition()] call enabled = isEnabled(state) =  False

   # [controls_thread() while 1 loop]  COMPUTE ACTUATORS (openpilot comment)
     > [controls_thread() while 1 loop]  call state_control(plan, CS, CP, state, events, ...)
       > state_control(plan, CS, CP, state, events) return actuators, ... selfdrive/controls/controlsd.py
       > # Given the state, this functions returns the actuators (openpilot comment) controlds.py state_control()
      > actuators = (gas = 0, brake = 0, steer = 0)  state_control()
      > [state_control()] call enabled = isEnabled(state) =  False
      > [state_control()] call active = isActive(state) =  False

      # *** gas/brake PID loop (openpilot comment) state_control()
          > call actuators.gas, actuators.break = LoC.update (active, CS.vEgo, ...) controlsd.py state_control()
> selfdrive/controls/lib/longcontrol.py LongControl(object).update(CP)
            > actuators.gas =  0.0 state_control()
            > actuators.brake =  -0.0 state_control()
              > type(actuators.brake) =  <type 'float'>

      # *** steering PID loop (openpilot comment) state_control()
          > call actuators.steer = LaC.update (active, CS.vEgo, ...) controlsd.py state_control()
         > selfdrive/controls/lib/latcontrol.py LatControl(object).update()
            > actuators.steer =  0.0 state_control()

   # [controls_thread() while 1 loop]  PUBLISH DATA (openpilot comment)
     > [controls_thread() while 1 loop]  call CC = data_send(plan, CS, CI, CP, VM, state, events, actuators, carstate, carcontrol, LaC, LoC, ...)
       > [controlsd.py] data_send(plan, CS, CI, CP, VM, state, events, actuators, car control) return CC selfdrive/controls/controlsd.py

       # [data_send()] **** control the car *****  (openpilot comment)
           > [data_send()]  call CC = car.CarControl.new_message controlsd.py
       [data_send() if not passive:] > call CC.enabled = isEnabled(state) =  False
         > [data_send()] call CC.actuators = actuators

       # [data_send()] send car controls over can (openpilot comment) with CI.apply(CC)
> CarInterface(object).apply(c) START selfdrive/car/toyota/interface.py 
> call self.CC.update(sendcan, CS, actuators, ...) selfdrive/car/toyota/interface.py CarInterface(object).apply(c) 
> CarController(object).update(sendcan, enabled, CS, actuators, ...) START selfdrive/car/toyota/carcontroller.py
> [data_send()] call dat.live100.enabled = isEnabled(state)
> [data_send()] call dat.live100.active = isActive(state)

       # [data_send()] car state (openpilot comment)

       # [data_send()] high level control state (openpilot comment)
           > [data_send()] dat.live100.state =  0

       # longitudinal control state (openpilot comment)
           > [data_send()] longitudinal control state

       # [data_send()] lateral control state (openpilot comment)

       # [data_send()] broadcast carState (openpilot comment)

       # [data_send()] broadcast carControls (openpilot comment)
           > [data_send()] call cc_send = messaging.new_message()
           > [data_send()] call carcontrol.send(cc_send.to_bybtes())
         > [data_send()] type(CC) =  <type 'capnp.lib.capnp._DynamicStructBuilder'>

      > ***** data_send() END ***** selfdrive/controls/controlsd.py

controlsd lagging by 2.36 ms
> ***** [controls_thread()] while 1 loop END *****

> ***** [controls_thread()] END ***** selfdrive/controls/controlsd.py

camera_qcom.c: user focus adjust: 0
      > [manager_thread() while 1 loop] call location = messaging.recv_sock(location_sock)
  > selfdrive/messaging.py recv_sock() sock =  18 return dat
      > [manager_thread()] while 1 loop call thermal_sock.send()
      > [manager_thread()] while 1 loop msg = ... 
       > [start_managed_process(name)] name =  uploader
       > [start_managed_process()]  uploader is already running or is not a managed process
  > [manager_thread() while 1 loop] should_start =  True
  > [manager_thread() while 1 loop] call start_managed_process(p)  controlsd
       > [start_managed_process(name)] name =  controlsd
       > [start_managed_process()]  controlsd is already running or is not a managed process
  > [manager_thread() while 1 loop] call start_managed_process(p)  loggerd
       > [start_managed_process(name)] name =  loggerd
       > [start_managed_process()]  loggerd is already running or is not a managed process
  > [manager_thread() while 1 loop] call start_managed_process(p)  sensord
       > [start_managed_process(name)] name =  sensord
       > [start_managed_process()]  sensord is already running or is not a managed process
  > [manager_thread() while 1 loop] call start_managed_process(p)  radard
       > [start_managed_process(name)] name =  radard
       > [start_managed_process()]  radard is already running or is not a managed process
  > [manager_thread() while 1 loop] call start_managed_process(p)  visiond
       > [start_managed_process(name)] name =  visiond
       > [start_managed_process()]  visiond is already running or is not a managed process
  > [manager_thread() while 1 loop] call start_managed_process(p)  proclogd
       > [start_managed_process(name)] name =  proclogd
       > [start_managed_process()]  proclogd is already running or is not a managed process

     > [manager_thread()] ***** while 1 loop END *****


    > [manager_thread()] ***** while 1 loop START
      > [manager_thread() while 1 loop] call td = messaging.recv_sock(health_sock, wait=True)
  > selfdrive/messaging.py recv_sock() sock =  17 return dat
      > [manager_thread() while 1 loop] call location = messaging.recv_sock(location_sock)
  > selfdrive/messaging.py recv_sock() sock =  18 return dat
      > [manager_thread()] while 1 loop call thermal_sock.send()
      > [manager_thread()] while 1 loop msg = ... 
       > [start_managed_process(name)] name =  uploader
       > [start_managed_process()]  uploader is already running or is not a managed process
  > [manager_thread() while 1 loop] should_start =  True
  > [manager_thread() while 1 loop] call start_managed_process(p)  controlsd
       > [start_managed_process(name)] name =  controlsd
       > [start_managed_process()]  controlsd is already running or is not a managed process
  > [manager_thread() while 1 loop] call start_managed_process(p)  loggerd
       > [start_managed_process(name)] name =  loggerd
       > [start_managed_process()]  loggerd is already running or is not a managed process
  > [manager_thread() while 1 loop] call start_managed_process(p)  sensord
       > [start_managed_process(name)] name =  sensord
       > [start_managed_process()]  sensord is already running or is not a managed process
  > [manager_thread() while 1 loop] call start_managed_process(p)  radard
       > [start_managed_process(name)] name =  radard
       > [start_managed_process()]  radard is already running or is not a managed process
  > [manager_thread() while 1 loop] call start_managed_process(p)  visiond
       > [start_managed_process(name)] name =  visiond
       > [start_managed_process()]  visiond is already running or is not a managed process
  > [manager_thread() while 1 loop] call start_managed_process(p)  proclogd
       > [start_managed_process(name)] name =  proclogd
       > [start_managed_process()]  proclogd is already running or is not a managed process

     > [manager_thread()] ***** while 1 loop END *****


    > [manager_thread()] ***** while 1 loop START
      > [manager_thread() while 1 loop] call td = messaging.recv_sock(health_sock, wait=True)
  > selfdrive/messaging.py recv_sock() sock =  17 return dat
      > [manager_thread() while 1 loop] call location = messaging.recv_sock(location_sock)
  > selfdrive/messaging.py recv_sock() sock =  18 return dat
      > [manager_thread()] while 1 loop call thermal_sock.send()
      > [manager_thread()] while 1 loop msg = ... 
       > [start_managed_process(name)] name =  uploader
       > [start_managed_process()]  uploader is already running or is not a managed process
  > [manager_thread() while 1 loop] should_start =  True
  > [manager_thread() while 1 loop] call start_managed_process(p)  controlsd
       > [start_managed_process(name)] name =  controlsd
       > [start_managed_process()]  controlsd is already running or is not a managed proc